Requirements:

- automake, autoconf, libtool
	(not needed when compiling a release)
- pkg-config (http://www.freedesktop.org/wiki/Software/pkg-config)
	(not needed when compiling a release using the included isl and pet)
- gmp (http://gmplib.org/)
- libyaml (http://pyyaml.org/wiki/LibYAML)
	(only needed if you want to compile the pet executable)
- LLVM/clang libraries, 2.9 or higher (http://clang.llvm.org/get_started.html)
	Unless you have some other reasons for wanting to use the svn version,
	it is best to install the latest release (3.3).
	For more details, see pet/README.

If you are installing on Ubuntu, then you can install the following packages:

automake autoconf libtool pkg-config libgmp3-dev libyaml-dev libclang-dev llvm

Note that you need at least version 3.2 of libclang-dev (ubuntu raring).
Older versions of this package did not include the required libraries.
If you are using an older version of ubuntu, then you need to compile and
install LLVM/clang from source.


Preparing:

Grab the latest release and extract it or get the source from
the git repository as follows.  This process requires autoconf,
automake, libtool and pkg-config.

	git clone git://repo.or.cz/ppcg.git
	cd ppcg
	git submodule init
	git submodule update
	./autogen.sh


Compilation:

	./configure
	make
	make check

If you have installed any of the required libraries in a non-standard
location, then you may need to use the --with-gmp-prefix,
--with-libyaml-prefix and/or --with-clang-prefix options
when calling "./configure".


Using PPCG to generate CUDA code

To convert a fragment of a C program to CUDA, insert a line containing

	#pragma scop

before the fragment and add a line containing

	#pragma endscop

after the fragment.  Then run
	
	ppcg --target=cuda file.c

where file.c is the file containing the fragment.  The generated
code is stored in file_host.cu and file_kernel.cu.

Specifying tile, grid and block sizes

The iterations space tile size, grid size and block size can
be specified using the --sizes option.  The argument is a union map
in isl notation mapping kernels identified by their sequence number
in a "kernel" space to singleton sets in the "tile", "grid" and "block"
spaces.  The sizes are specified outermost to innermost.

The dimension of the "tile" space indicates the (maximal) number of loop
dimensions to tile.  The elements of the single integer tuple
specify the tile sizes in each dimension.

The dimension of the "grid" space indicates the (maximal) number of block
dimensions in the grid.  The elements of the single integer tuple
specify the number of blocks in each dimension.

The dimension of the "block" space indicates the (maximal) number of thread
dimensions in the grid.  The elements of the single integer tuple
specify the number of threads in each dimension.

For example,

    { kernel[0] -> tile[64,64]; kernel[i] -> block[16] : i != 4 }

specifies that in kernel 0, two loops should be tiled with a tile
size of 64 in both dimensions and that all kernels except kernel 4
should be run using a block of 16 threads.

Since PPCG performs some scheduling, it can be difficult to predict
what exactly will end up in a kernel.  If you want to specify
tile, grid or block sizes, you may want to run PPCG first with the defaults,
examine the kernels and then run PPCG again with the desired sizes.


Compiling the generated code with nvcc

To get optimal performance from nvcc, it is important to choose --arch
according to your target GPU.  Specifically, use the flag "--arch sm_20"
for fermi, "--arch sm_30" for GK10x Kepler and "--arch sm_35" for
GK110 Kepler.  We discourage the use of older cards as we have seen
correctness issues with compilation for older architectures.
Note that in the absence of any --arch flag, nvcc defaults to
"--arch sm_13". This will not only be slower, but can also cause
correctness issues.
